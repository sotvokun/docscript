+==================================+
|           Standard Forms         |
+==================================+
Form Name     Syntax Rule
--------------------------------------------
Definition => <atom::identifier::[define]> , <atom::identifier> , <sexpression>
Assignment => <atom::identifier::[set!]> , <atom::identifier> , <sexpression>
Lambda     => <atom::identifier::[lambda]> | <atom::identifier::[Î»]> , <sexpression_list::{<atom::identifier>*}> | <sexpression>::<atom::identifier> , <sexpression>
Logic_And  => <atom::identifier::[and]> , <sexpression>*
Logic_Or   => <atom::identifier::[or]> , <sexpression>*
IfElse     => <atom::identifier::[if]> , <sexpression> , <sexpression> , <sexpression>
For        => <atom::identifier::[for]> , <atom::identifier> , <list> | <sexpression> , <sexpression>
 
 
 
+==================================+
|        Standard Data Type        |
+==================================+
Type Name           Literal             Instruction
----------------------------------------------------------------------------------------
symbol              <symbol>
number              <number>            A number that can be represented to the integer and the float-point
string              <string>            A sequence of human text
boolean             <boolean>
list                <list>|<text>       A data struct stored another data type values (include list), <text> is a special list that store string.
procedure           Lambda Form         A callable object that can be pass another data types values (include procedure), and return a value



+==================================+
|        Standard Procedure        |
+==================================+
Name            Parameters                  Return          Instruction
----------------------------------------------------------------------------------------
#Construction
list            ...                         list            construct a list, the same of the round bracket list
pair            x:any y:any                 list            construct a list that only store two value, the same of the round bracket list have two value inside

#Equivalence
equal?          x:any y:any ...             boolean         check the parameter is equal or not, if the x and y is not the same data type the result is false

#Type conversion
symbol->string  x:symbol                    string
number->string  x:number                    string
number->boolean x:number                    boolean         non-zero value is positive, zero is negative
string->number  x:string                    number|list     return empty list if the string can not be converted correctly
string->boolean x:string                    boolean|list    return empty list if the string can not be converted correctly
string->symbol  x:string                    symbol|list     return empty list if the string can not be converted correctly
boolean->number x:boolean                   number          `false` is 0, `true` is 1
boolean->string x:boolean                   string
list->string    x:list                      string
list->boolean   x:list                      boolean         empty list is `false`, otherwise is `true`

#Identity predicate
symbol?         x:any                       boolean
number?         x:any                       boolean
string?         x:any                       boolean
boolean?        x:any                       boolean
list?           x:any                       boolean
pair?           x:any                       boolean
procedure?      x:any                       boolean
type->string    x:any                       string          return the data type string of x. NOTE: `pair` is "list"
type->symbol    x:any                       symbol          return the data type symbol of x. NOTE: `pair` is 'list

#Logical
not             x:boolean                   boolean         the boolean logical not

#Number
#See Number Procedure table

#String
string-length   x:string                    number          get the length of string
string-equal?   x:string y:string           boolean
string-gt?      x:string y:string           boolean         check the length of x is whether greater than the length of y, if the length is equal, then compare each character by alphabet order 
string-lt?      x:string y:string           boolean         check the length of x is whether less than the length of y, if the length is equal, then compare each character by alphabet order
string-concat   ...:string                  string          ALIAS:string-append concatenate strings to one string
string-append   x:string ...:string         string          add more content after x
string-prefix   x:string y:string           string          add y before x
string-suffix   x:string y:string           string          add y after x, the same of the string-append only add one content
string-ltrim    x:string                    string          remove all empty characters before the first non-empty character
string-rtrim    x:string                    string          remove all empty characters afther the last non-empty character
string-trim     x:string                    string          remove all empty characters before the first non-empty character and after the last non-empty character
string-split    x:string y:string           list            split x to a list of string by y
substring       x:string i:number l:number  string          get part of the string x, get l characters from the i-th. if the l is negative or zero, get characters from the i-th to the end

#List and Pair
length          x:list                      number          the number of the values that store in the list
first           x:list                      any             the first value of the list
last            x:list                      any             the last value of the list
nth             x:list n:number             any             the n-th value of list, if n is greater than length of list, it will return an error information list
reverse         x:list                      list
car             x:list                      any             get the first value of the list
cdr             x:list                      list            the list that stored values except the first of the x, if the x only have one value, the result is an empty list
concat          ...:list                    list            concatenate lists to one list
append          x:list ...:any              list            add more object into the list x
empty?          x:list                      boolean         check the list is empty or not



+==================================+
|          Number Procedure        |
+==================================+
Name            Parameters                  Return          Instruction
----------------------------------------------------------------------------------------
#Basic arithmetic
+               x:number ...                number          if the argument is only x, and x is negative, return it's correspond positive number
-               x:number ...                number          if the arugment is only x, and x is positive, return it's correspond negative number
*               x:number y:number ...       number
/               x:number y:number ...       number
quotient        x:number y:number           number          
remainder       x:number y:number           number          
modulo          x:number y:number           number          
expt            x:number y:number           number          NOTE: x^y
sqrt            x:number                    number
abs             x:number                    number
gcd             x:number y:number           number
lcm             x:number y:number           number

#approximation
floor           x:number                    number          
ceiling         x:number                    number          
truncate        x:number                    number          
round           x:number                    number          

#Inequalities
>               x:number y:number ...       boolean
<               x:number y:number ...       boolean
=               x:number y:number ...       boolean
>=              x:number y:number ...       boolean
<=              x:number y:number ...       boolean

#Trigonometry
sin             x:number                    number
cos             x:number                    number
tan             x:number                    number
asin            x:number                    number
acos            x:number                    number
atan            x:number                    number

#Exponentials
exp             x:number                    number          NOTE:e()
log             x:number                    number          NOTE:log()

#Maximum and Minimum
max             ...                         number          return the max value of number if no argument, return itself if only one argument, return max value in otherwise
min             ...                         number          return the min value of number if no argument, return itself if only one argument, return min value in otherwise

#Miscellaneous predicates
positive?       x:number                    boolean
negative?       x:number                    boolean
integer?        x:number                    boolean
floor?          x:number                    boolean
zero?           x:number                    boolean
odd?            x:number                    boolean
even?           x:number                    boolean



+==================================+
|        Extended Procedure        |
+==================================+
#IO
write-string    f:string x:string           boolean         write the string x into file at path f, return `true` if the writing is successful, otherwise return `false`
read-string     f:string                    string|list     read the content as string from the file at path f, return string if the reading is successful, otherwise return the error information list
message         m:string                    string          write the message into standard output stream and fresh it. return the message itself

#Environment
env-new         x:string                    list            create a new environment with name x, return an environment list
env-get         x:list y:string             any             get the definition in the environment x, by the definition name y, if the name is not existed, return an error information
env-def         x:list y:string z:any       list            add the definition in the environment x, with the name and its value. If the the name is existed, it will be overwrite to the new value
current-env                                 list            get current environment

#System
eval            x:string                    list            eval the docscript string, return the evaluation information list
eval-env        x:string y:list             list            eval the docscript string, return the evaluation information list, the definition will be inject into the  environment y
load!           x:string                    list            load and evaluate the file at the path x, return the evaluation information list, the definition will be inject current environment

#Docsir
error           x:string                    any             throw an error with a line of message


+==================================+
|           Special List           |
+==================================+
Name                        Definition
--------------------------------------------
Definition List             [name:symbol, value:any]*
Environment                 identifier:'__INTERPRETER_ENV:symbol , name:string , deflist:Definition_List , last_result:any